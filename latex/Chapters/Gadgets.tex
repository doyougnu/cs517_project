\label{section:gadgets}
%
\begin{figure}[h]
  \centering
  \begin{lstlisting}[language=python,caption={Cycle check gadget. \texttt{v\_from}
  and \texttt{v\_to} are symbolic variables in the solver. \texttt{name} is the constraint
  label in the solver. The cycle check replaces each edge with the constraint
  that previous vertices must be a lesser integer value than future vertices}]
  def cycle_check(solver,v_from,v_to,name):
      solver.assert_and_track(v_from < v_to, name)
  \end{lstlisting}
\end{figure}

Our approach is to translate an exact integer programming method by
\citet{alietall} to an \ac{smt} problem. The translation to an \ac{smt} problem
is straightforward, requiring no changes from linear program encoding to an
\ac{smt} encoding.

To find the minimum feedback arc set of a graph \grph{G}, the method requires a
cycle matrix, \cmatrix{i}{j}. The cycle matrix tracks which edges are in which
cycles in the graph. For some edge \symEdge{j}, if \symEdge{j} participates in
cycle $\kf{i}$ then \cmatrix{i}{j} = 1 otherwise \cmatrix{i}{j} = 0, indicating
that \symEdge{j} \emph{does not} participate in the $\kf{i}$th cycle. For
example, consider the edge \edge{B}{D} from \autoref{fig:three-cycle} and assume
\edge{B}{D} has edge ID $\kf{j} = 3$, if the 0th cycle in
\autoref{fig:three-cycle} is composed of edges: \edge{A}{B}, \edge{B}{C}, and
\edge{C}{A}, then \cmatrix{0}{3} = 0. Similarly, assuming \edge{A}{B} has edge
ID $\kf{j} = 0$, then \cmatrix{0}{0} = 1 because \edge{A}{B} participates in
cycle 0.

With the cycle matrix, the method is composed of $\kf{c}$ constraints, where
$\kf{c}$ is the number of cycles and a minimization over the sum of edges. Each
edge, \edge{i}{j} is encoded as a binary integer \ac{smt} variable \symEdge{j},
where $\kf{j}$ is the edge's unique ID. The \ac{smt} variable \symEdge{j} only
ranges from 0 to 1, indicating whether the $\kf{j}$th edge is in the minimum
feedback arc set (\symEdge{j} = 1) or not (\symEdge{j} = 0). We express the
constraints in the following equations:
%
\begin{equation}
  \label{one}
 \minimize \sum_{j=1}^{\magnitude{E}} \symEdge{j}
\end{equation}
%
\begin{equation}
  \label{two}
  (\sum_{j=1}^{\magnitude{E}} \cmatrix{i}{j} \symEdge{j}) \ge 1, \, \text{for each } i = 0, 1, 2 \dots{}, c
\end{equation}

Conceptually, \autoref{one} requires the \ac{smt} solver to consider all edges
in the graph \grph{G} and find the smallest number of edges which compose a
feedback arc set. The encoding of a feedback arc set occurs in \autoref{two}.
With the constraint $\sum (\dots) \ge 1$ for the $\kf{i}$th cycle, \autoref{two}
states that for each cycle in the graph \grph{G} pick one or more edges. By
$\sum (\cmatrix{i}{j} \symEdge{j}) \ge 1$, \autoref{two} forces the \ac{smt}
solver to consider edges that occur in most cycles. The logic is easiest to
observe with an example, consider the graph shown in \autoref{fig:three-cycle},
with the edge and cycle IDs shown in \autoref{table}:
%
\begin{table}
  \begin{subtable}[t]{0.20\textwidth}
  \begin{tabular}{|c c|}
    \hline
    Edge & ID \\ [0.5ex]
    \hline\hline
    \edge{A}{B} & 0 \\
    \edge{B}{C} & 1 \\
    \edge{C}{A} & 2 \\
    \edge{B}{D} & 3 \\
    \edge{D}{E} & 4 \\
    \edge{E}{F} & 5 \\
    \edge{F}{C} & 6 \\
    \edge{F}{D} & 7 \\ [1ex]
    \hline
  \end{tabular}%
\end{subtable}%
~
\begin{subtable}[t]{0.80\textwidth}
  \begin{tabular}{|c c|}
    \hline
    Cycle & Cycle edges \\ [0.5ex]
    \hline\hline
    0 & \edge{A}{B} $\rightarrow$ \edge{B}{C} $\rightarrow$ \edge{C}{A} \\[0.5ex]
    1 & \edge{D}{E} $\rightarrow$ \edge{E}{F} $\rightarrow$ \edge{F}{D} \\[0.5ex]
    \multirow{2}{2em}{\centering 2} & \edge{A}{B} $\rightarrow$ \edge{B}{D} $\rightarrow$ \edge{D}{E} \\
                         & \edge{E}{F} $\rightarrow$ \edge{F}{C} $\rightarrow$ \edge{C}{A} \\
    \hline
  \end{tabular}%
\end{subtable}
\caption{Table of Edge IDs and Cycle IDs for \autoref{fig:three-cycle}}%
\label{table}%
\end{table}
%
For this graph, the constraints generated by \autoref{two} would be:
%
\begin{align*}
  1\symEdge{0} + 1\symEdge{1} + 1\symEdge{2} + 0\symEdge{3} + 0\symEdge{4} + 0\symEdge{5} + 0\symEdge{6} + 0\symEdge{7} \ge 1 & \qquad \text{Cycle 0} \\
  0\symEdge{0} + 0\symEdge{1} + 0\symEdge{2} + 0\symEdge{3} + 1\symEdge{4} + 1\symEdge{5} + 0\symEdge{6} + 1\symEdge{7} \ge 1 & \qquad \text{Cycle 1} \\
  1\symEdge{0} + 0\symEdge{1} + 1\symEdge{2} + 1\symEdge{3} + 1\symEdge{4} + 1\symEdge{5} + 1\symEdge{6} + 0\symEdge{7} \ge 1 & \qquad \text{Cycle 2}
\end{align*}

Where we see the edge \symEdge{0} (edge \edge{A}{B}) occurs in cycles 0, and 2
(as \cmatrix{0}{0} and \cmatrix{2}{0} = 1). Therefore, the easiest way for the
\ac{smt} solver to satisfy these constraints \emph{and} the minimization
constraint is to set $\symEdge{0} = 1$. However, doing so will not satisfy the
cycle constraints for cycle 1, thus the solver must pick either \symEdge{4}
(\edge{D}{E}), \symEdge{5} (\edge{E}{F}), or \symEdge{7} (\edge{F}{C}). Again
the simplest path is to pick \symEdge{4}, or \symEdge{5} as setting these
variables to 1 satisfies more than one constraint. Thus, we see that by this
encoding the \ac{smt} solver is forced to minimize the number of edges to pick,
and therefore maximize the number of cycle constraints satisfied by setting a
given edge to 1, which corresponds to finding the minimum feedback arc set of a
graph.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End: